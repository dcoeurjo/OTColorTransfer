{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Color Transfer via Sliced Optimal Transport Introduction Color transfer is an image processing application where you want to retarget the color histogram of an input image according to the color histogram of a target one. Example: Input image Target image Color transfer output The idea of this project is to detail a color transfer solution that considers the Optimal Transport as a way to deform histograms in the most efficient way (see below for details). The literature is huge on the subject but I would like to emphasize the fact that efficient implementations of these tools are not so difficult. This project contains both this documentation and some C++ codes that implement the color transfer with as few dependencies as possible (just modern C++ compiler with OpenMP for best performances). Building the code To compile the tools, just clone the repository and use cmake to build the project: git clone https://github.com/dcoeurjo/OTColorTransfer.git cd OTColorTransfer mkdir build ; cd build cmake .. -DCMAKE_BUILD_TYPE = Release make Everything should compile with C++11 compiler. The only dependency is OpenMP for multithread features that is usually shipped with the compiler by default. On Apple MacOS, the default clang compiler does not have OpenMP. Just install omp ( brew install omp ) and use the following cmake command line: cmake .. -DOpenMP_C_LIB_NAMES=\"omp\" -DOpenMP_CXX_FLAGS=\"-Xpreprocessor -fopenmp \\ -I/usr/local/opt/libomp/include\" -DOpenMP_CXX_LIB_NAMES=\"omp\" \\ -DOpenMP_omp_LIBRARY=/usr/local/opt/libomp/lib/libomp.dylib \\ -DOpenMP_C_FLAGS=\"-Xpreprocessor -fopenmp -I/usr/local/opt/libomp/include\" The theory: Optimal Transport and Sliced Optimal Transport As mentioned above, the key tool will be Optimal Transport (OT for short) which can be sketched as follows: Given two probability (Radon) measures \\mu\\in X \\mu\\in X and \\nu\\in Y \\nu\\in Y , and a cost function c(\\cdot,\\cdot): X\\times Y \\rightarrow \\mathbb{R}^+ c(\\cdot,\\cdot): X\\times Y \\rightarrow \\mathbb{R}^+ , an optimal transport plan T: X\\rightarrow Y T: X\\rightarrow Y minimizes {\\displaystyle \\inf \\left\\{\\left.\\int _{X}c(x,T(x))\\,\\mathrm {d} \\mu (x)\\;\\right|\\;T_{*}(\\mu )=\\nu \\right\\}.} {\\displaystyle \\inf \\left\\{\\left.\\int _{X}c(x,T(x))\\,\\mathrm {d} \\mu (x)\\;\\right|\\;T_{*}(\\mu )=\\nu \\right\\}.} The cost of the optimal transport defines a metric between Radon measure. We can define the p^{th} p^{th} Wasserstein metric , \\mathcal{W}_p(\\mu,\\nu) \\mathcal{W}_p(\\mu,\\nu) as \\displaystyle \\mathcal{W}_{p}(\\mu ,\\nu ):={\\left(\\displaystyle \\inf \\left\\{\\left.\\int _{X}c(x,T(x))^p\\,\\mathrm {d} \\mu (x)\\;\\right|\\;T_{*}(\\mu )=\\nu \\right\\}\\right)^{1/p}} \\displaystyle \\mathcal{W}_{p}(\\mu ,\\nu ):={\\left(\\displaystyle \\inf \\left\\{\\left.\\int _{X}c(x,T(x))^p\\,\\mathrm {d} \\mu (x)\\;\\right|\\;T_{*}(\\mu )=\\nu \\right\\}\\right)^{1/p}} An analogy with piles of sand is usually used to explain the definition: let us consider that \\mu \\mu is a pile of sand and \\nu \\nu a hole (with the same volume or mass ), if we consider that the cost of moving an elementary volume of sand from on point to the other is proportional to the Euclidean distance ( l_2 l_2 cost function), then the optimal transport plan gives you the most efficient way to move all the sand from \\mu \\mu to \\nu \\nu . Again, the literature is huge and there are many alternative definitions, please refer to Computational Optimal Transport for a more complete introduction to the subject. The link between OT and color transfer follows the observation that color histograms are discrete Radon measures. As we are looking for the most efficient transformation of the input image histogram to match with the target one, the color transfer problem can be reformulate as a discrete OT one 1 2 3 4 5 6 . There are many numerical solutions to compute the OT (with continuous, discrete, semi-discrete measures, w/o regularization\u2026). We focus here on the sliced formulation of the OT and associated 2-Wasserstein metric in dimension d d : SW(\\mu,\\nu)^2 := \\int_{S^d} \\mathcal{W}_2( P_{\\theta,\\sharp}\\mu,P_{\\theta,\\sharp}\\nu)^2 d\\theta\\,. SW(\\mu,\\nu)^2 := \\int_{S^d} \\mathcal{W}_2( P_{\\theta,\\sharp}\\mu,P_{\\theta,\\sharp}\\nu)^2 d\\theta\\,. The sliced formulation consists in projecting the measures onto a 1D line ( P_{\\theta,\\sharp}: \\mathbb{R}^d\\rightarrow \\mathbb{R} P_{\\theta,\\sharp}: \\mathbb{R}^d\\rightarrow \\mathbb{R} ), solving the 1D OT problem on the projections and average the results for all directions ( S^d S^d is the unit hypersphere in dimension d d ). If the measures are discrete as sum of Diracs centered at points \\{x_i\\} \\{x_i\\} and \\{y_i\\} \\{y_i\\} in \\mathbb{R}^d \\mathbb{R}^d ( \\mu := \\frac{1}{n}\\sum_{x_i} \\delta_{x_i} \\mu := \\frac{1}{n}\\sum_{x_i} \\delta_{x_i} , \\nu := \\frac{1}{n}\\sum_{y_i} \\delta_{y_i} \\nu := \\frac{1}{n}\\sum_{y_i} \\delta_{y_i} ), then the 1D OT is obtained by sorting the projections and computing the difference between the first projected point of \\mu \\mu with the first projected point of \\nu \\nu , the second with the second, etc\u2026 $$ SW(\\mu,\\nu)^2 = \\int_{S^d} \\left(|\\langle x_{\\sigma_\\theta(i)} - y_{\\kappa_\\theta(i)},\\theta\\rangle| ^2\\right) d\\theta\\,,$$ ( \\sigma_\\theta(i) \\sigma_\\theta(i) a,d {\\kappa_\\theta(i)} {\\kappa_\\theta(i)} are permutations with increasing order). Numerically, we sample the set of directions S^d S^d and thus consider a finite number of slices . Sliced OT Color Transfer Back to our histogram transfer problem, Diracs centers \\{x_i\\} \\{x_i\\} are points in RGB space (one Dirac per pixel of the input image), and \\{y_i\\} \\{y_i\\} are the colors of the target image. Matching the histogram can be seen a transportation of the point cloud \\mu \\mu to \\nu \\nu in \\mathbb{R^3} \\mathbb{R^3} (the RGB color space). The idea is to advect points of \\mu \\mu such that we minimize SW(\\mu,\\nu) SW(\\mu,\\nu) . As described in the literature 1 4 , this amounts to project he points onto a random direction \\theta \\theta , align the sorted projections and advect \\mu \\mu in the \\theta \\theta direction by |\\langle x_{\\sigma_\\theta(i)} - y_{\\kappa_\\theta(i)},\\theta\\rangle| |\\langle x_{\\sigma_\\theta(i)} - y_{\\kappa_\\theta(i)},\\theta\\rangle| . and we iterate. Note that instead of advecting \\mu \\mu for each \\theta \\theta , we can accumulate advection vectors into a small batch and perform the transport step once the batch is full 4 . For enough slices (see the code for the experiments), we end up with a retarged input image. If K K denotes the number of slices, the overall computational cost of the approach in dimension d d is in O(d\\,K\\, N\\log N) O(d\\,K\\, N\\log N) . Note that the transport plan can be regularized using a simple post-processing, e.g. a bilateral filter of the transportation map (difference between the input image and the retargeted one) which is then applied to the input image 4 . Sliced Partial Optimal Transport The original sliced OT requires the two measures to have the exact same number of Diracs ( e.g. e.g. input and target images must have the same size). When dealing with measures of different sizes, the combinatorial problem is more complex in the sense that we are not looking for a minimal cost bijective map between the Diracs, but an injective one. This problem is intensively discussed in the Sliced Partial Optimal Transport SIGGRAPH paper 6 . In color matching applications such as that of [Piti\u00e9 et al. 2005] 1 , matching all pixels of an input image (a) seen as 3D points in an RGB space to all pixels of a target image (b) can lead to erroneous transfers (c) due to mismatched content (here, trees of the target are not present in the input, and distort colors in the output). Francois Pitie\u0301, Anil C. Kokaram, and Rozenn Dahyot. 2005. N-Dimensional Probablility Density Function Transfer and Its Application to Colour Transfer. In Proceedings of the Tenth IEEE International Conference on Computer Vision - Volume 2 (ICCV \u201905). IEEE Computer Society, Washington, DC, USA, 1434\u20131439. https://doi.org/10.1109/ ICCV.2005.166 \u21a9 \u21a9 \u21a9 Franc\u0327ois Pitie\u0301, Anil C Kokaram, and Rozenn Dahyot. 2007. Automated colour grading using colour distribution transfer. Computer Vision and Image Understanding 107, 1-2 (2007), 123\u2013137. \u21a9 Nicolas Bonneel, Julien Rabin, G. Peyre\u0301, and Hanspeter Pfister. 2015. Sliced and Radon Wasserstein Barycenters of Measures. J. of Mathematical Imaging and Vision 51, 1 (2015). \u21a9 Julien Rabin, Julie Delon, and Yann Gousseau. 2010. Regularization of transportation maps for color and contrast transfer. In Image Processing (ICIP), 2010 17th IEEE International Conference on. IEEE, 1933\u20131936. \u21a9 \u21a9 \u21a9 \u21a9 Nicolas Bonneel, Kalyan Sunkavalli, Sylvain Paris, and Hanspeter Pfister. 2013. Example- Based Video Color Grading. ACM Trans. Graph. (SIGGRAPH) 32, 4 (2013). \u21a9 Nicolas Bonneel and David Coeurjolly. 2019. Sliced Partial Optimal Transport. ACM Trans. Graph. (SIGGRAPH) 38, 4 (2019). \u21a9 \u21a9","title":"Introduction"},{"location":"#color-transfer-via-sliced-optimal-transport","text":"","title":"Color Transfer via Sliced Optimal Transport"},{"location":"#introduction","text":"Color transfer is an image processing application where you want to retarget the color histogram of an input image according to the color histogram of a target one. Example: Input image Target image Color transfer output The idea of this project is to detail a color transfer solution that considers the Optimal Transport as a way to deform histograms in the most efficient way (see below for details). The literature is huge on the subject but I would like to emphasize the fact that efficient implementations of these tools are not so difficult. This project contains both this documentation and some C++ codes that implement the color transfer with as few dependencies as possible (just modern C++ compiler with OpenMP for best performances).","title":"Introduction"},{"location":"#building-the-code","text":"To compile the tools, just clone the repository and use cmake to build the project: git clone https://github.com/dcoeurjo/OTColorTransfer.git cd OTColorTransfer mkdir build ; cd build cmake .. -DCMAKE_BUILD_TYPE = Release make Everything should compile with C++11 compiler. The only dependency is OpenMP for multithread features that is usually shipped with the compiler by default. On Apple MacOS, the default clang compiler does not have OpenMP. Just install omp ( brew install omp ) and use the following cmake command line: cmake .. -DOpenMP_C_LIB_NAMES=\"omp\" -DOpenMP_CXX_FLAGS=\"-Xpreprocessor -fopenmp \\ -I/usr/local/opt/libomp/include\" -DOpenMP_CXX_LIB_NAMES=\"omp\" \\ -DOpenMP_omp_LIBRARY=/usr/local/opt/libomp/lib/libomp.dylib \\ -DOpenMP_C_FLAGS=\"-Xpreprocessor -fopenmp -I/usr/local/opt/libomp/include\"","title":"Building the code"},{"location":"#the-theory-optimal-transport-and-sliced-optimal-transport","text":"As mentioned above, the key tool will be Optimal Transport (OT for short) which can be sketched as follows: Given two probability (Radon) measures \\mu\\in X \\mu\\in X and \\nu\\in Y \\nu\\in Y , and a cost function c(\\cdot,\\cdot): X\\times Y \\rightarrow \\mathbb{R}^+ c(\\cdot,\\cdot): X\\times Y \\rightarrow \\mathbb{R}^+ , an optimal transport plan T: X\\rightarrow Y T: X\\rightarrow Y minimizes {\\displaystyle \\inf \\left\\{\\left.\\int _{X}c(x,T(x))\\,\\mathrm {d} \\mu (x)\\;\\right|\\;T_{*}(\\mu )=\\nu \\right\\}.} {\\displaystyle \\inf \\left\\{\\left.\\int _{X}c(x,T(x))\\,\\mathrm {d} \\mu (x)\\;\\right|\\;T_{*}(\\mu )=\\nu \\right\\}.} The cost of the optimal transport defines a metric between Radon measure. We can define the p^{th} p^{th} Wasserstein metric , \\mathcal{W}_p(\\mu,\\nu) \\mathcal{W}_p(\\mu,\\nu) as \\displaystyle \\mathcal{W}_{p}(\\mu ,\\nu ):={\\left(\\displaystyle \\inf \\left\\{\\left.\\int _{X}c(x,T(x))^p\\,\\mathrm {d} \\mu (x)\\;\\right|\\;T_{*}(\\mu )=\\nu \\right\\}\\right)^{1/p}} \\displaystyle \\mathcal{W}_{p}(\\mu ,\\nu ):={\\left(\\displaystyle \\inf \\left\\{\\left.\\int _{X}c(x,T(x))^p\\,\\mathrm {d} \\mu (x)\\;\\right|\\;T_{*}(\\mu )=\\nu \\right\\}\\right)^{1/p}} An analogy with piles of sand is usually used to explain the definition: let us consider that \\mu \\mu is a pile of sand and \\nu \\nu a hole (with the same volume or mass ), if we consider that the cost of moving an elementary volume of sand from on point to the other is proportional to the Euclidean distance ( l_2 l_2 cost function), then the optimal transport plan gives you the most efficient way to move all the sand from \\mu \\mu to \\nu \\nu . Again, the literature is huge and there are many alternative definitions, please refer to Computational Optimal Transport for a more complete introduction to the subject. The link between OT and color transfer follows the observation that color histograms are discrete Radon measures. As we are looking for the most efficient transformation of the input image histogram to match with the target one, the color transfer problem can be reformulate as a discrete OT one 1 2 3 4 5 6 . There are many numerical solutions to compute the OT (with continuous, discrete, semi-discrete measures, w/o regularization\u2026). We focus here on the sliced formulation of the OT and associated 2-Wasserstein metric in dimension d d : SW(\\mu,\\nu)^2 := \\int_{S^d} \\mathcal{W}_2( P_{\\theta,\\sharp}\\mu,P_{\\theta,\\sharp}\\nu)^2 d\\theta\\,. SW(\\mu,\\nu)^2 := \\int_{S^d} \\mathcal{W}_2( P_{\\theta,\\sharp}\\mu,P_{\\theta,\\sharp}\\nu)^2 d\\theta\\,. The sliced formulation consists in projecting the measures onto a 1D line ( P_{\\theta,\\sharp}: \\mathbb{R}^d\\rightarrow \\mathbb{R} P_{\\theta,\\sharp}: \\mathbb{R}^d\\rightarrow \\mathbb{R} ), solving the 1D OT problem on the projections and average the results for all directions ( S^d S^d is the unit hypersphere in dimension d d ). If the measures are discrete as sum of Diracs centered at points \\{x_i\\} \\{x_i\\} and \\{y_i\\} \\{y_i\\} in \\mathbb{R}^d \\mathbb{R}^d ( \\mu := \\frac{1}{n}\\sum_{x_i} \\delta_{x_i} \\mu := \\frac{1}{n}\\sum_{x_i} \\delta_{x_i} , \\nu := \\frac{1}{n}\\sum_{y_i} \\delta_{y_i} \\nu := \\frac{1}{n}\\sum_{y_i} \\delta_{y_i} ), then the 1D OT is obtained by sorting the projections and computing the difference between the first projected point of \\mu \\mu with the first projected point of \\nu \\nu , the second with the second, etc\u2026 $$ SW(\\mu,\\nu)^2 = \\int_{S^d} \\left(|\\langle x_{\\sigma_\\theta(i)} - y_{\\kappa_\\theta(i)},\\theta\\rangle| ^2\\right) d\\theta\\,,$$ ( \\sigma_\\theta(i) \\sigma_\\theta(i) a,d {\\kappa_\\theta(i)} {\\kappa_\\theta(i)} are permutations with increasing order). Numerically, we sample the set of directions S^d S^d and thus consider a finite number of slices .","title":"The theory: \u00a0Optimal Transport and Sliced Optimal Transport"},{"location":"#sliced-ot-color-transfer","text":"Back to our histogram transfer problem, Diracs centers \\{x_i\\} \\{x_i\\} are points in RGB space (one Dirac per pixel of the input image), and \\{y_i\\} \\{y_i\\} are the colors of the target image. Matching the histogram can be seen a transportation of the point cloud \\mu \\mu to \\nu \\nu in \\mathbb{R^3} \\mathbb{R^3} (the RGB color space). The idea is to advect points of \\mu \\mu such that we minimize SW(\\mu,\\nu) SW(\\mu,\\nu) . As described in the literature 1 4 , this amounts to project he points onto a random direction \\theta \\theta , align the sorted projections and advect \\mu \\mu in the \\theta \\theta direction by |\\langle x_{\\sigma_\\theta(i)} - y_{\\kappa_\\theta(i)},\\theta\\rangle| |\\langle x_{\\sigma_\\theta(i)} - y_{\\kappa_\\theta(i)},\\theta\\rangle| . and we iterate. Note that instead of advecting \\mu \\mu for each \\theta \\theta , we can accumulate advection vectors into a small batch and perform the transport step once the batch is full 4 . For enough slices (see the code for the experiments), we end up with a retarged input image. If K K denotes the number of slices, the overall computational cost of the approach in dimension d d is in O(d\\,K\\, N\\log N) O(d\\,K\\, N\\log N) . Note that the transport plan can be regularized using a simple post-processing, e.g. a bilateral filter of the transportation map (difference between the input image and the retargeted one) which is then applied to the input image 4 .","title":"Sliced OT Color Transfer"},{"location":"#sliced-partial-optimal-transport","text":"The original sliced OT requires the two measures to have the exact same number of Diracs ( e.g. e.g. input and target images must have the same size). When dealing with measures of different sizes, the combinatorial problem is more complex in the sense that we are not looking for a minimal cost bijective map between the Diracs, but an injective one. This problem is intensively discussed in the Sliced Partial Optimal Transport SIGGRAPH paper 6 . In color matching applications such as that of [Piti\u00e9 et al. 2005] 1 , matching all pixels of an input image (a) seen as 3D points in an RGB space to all pixels of a target image (b) can lead to erroneous transfers (c) due to mismatched content (here, trees of the target are not present in the input, and distort colors in the output). Francois Pitie\u0301, Anil C. Kokaram, and Rozenn Dahyot. 2005. N-Dimensional Probablility Density Function Transfer and Its Application to Colour Transfer. In Proceedings of the Tenth IEEE International Conference on Computer Vision - Volume 2 (ICCV \u201905). IEEE Computer Society, Washington, DC, USA, 1434\u20131439. https://doi.org/10.1109/ ICCV.2005.166 \u21a9 \u21a9 \u21a9 Franc\u0327ois Pitie\u0301, Anil C Kokaram, and Rozenn Dahyot. 2007. Automated colour grading using colour distribution transfer. Computer Vision and Image Understanding 107, 1-2 (2007), 123\u2013137. \u21a9 Nicolas Bonneel, Julien Rabin, G. Peyre\u0301, and Hanspeter Pfister. 2015. Sliced and Radon Wasserstein Barycenters of Measures. J. of Mathematical Imaging and Vision 51, 1 (2015). \u21a9 Julien Rabin, Julie Delon, and Yann Gousseau. 2010. Regularization of transportation maps for color and contrast transfer. In Image Processing (ICIP), 2010 17th IEEE International Conference on. IEEE, 1933\u20131936. \u21a9 \u21a9 \u21a9 \u21a9 Nicolas Bonneel, Kalyan Sunkavalli, Sylvain Paris, and Hanspeter Pfister. 2013. Example- Based Video Color Grading. ACM Trans. Graph. (SIGGRAPH) 32, 4 (2013). \u21a9 Nicolas Bonneel and David Coeurjolly. 2019. Sliced Partial Optimal Transport. ACM Trans. Graph. (SIGGRAPH) 38, 4 (2019). \u21a9 \u21a9","title":"Sliced Partial Optimal Transport"},{"location":"Changelog/","text":"Nov 21, 2019: adding python code by @iperov Aug 30, 2019: first version (CPU balanced and partial Sliced OT)","title":"Changelog"},{"location":"Contributing/","text":"This project is an open source one and accept any contribution. If you have spotted some typos or would like to improve the code, do not hesitate to create a pull-request on Github. The documentation sources are Markdown files in the docs-source folder. The static web site can ( docs folder) can be generated using python mkdocs : python3 -m mkdocs build","title":"Contributing"},{"location":"license/","text":"David Coeurjolly , CNRS, Universit\u00e9 de Lyon, LIRIS. /* Copyright (c) 2019 CNRS David Coeurjolly <david.coeurjolly@liris.cnrs.fr> All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIEDi WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ The Sliced Partial Optimal Transport SPOT code follows a similar license ( Nicolas Bonneel , David Coeurjolly ). stb_image.h/stb_image_writer.h are public domain. Cimg uses CeCILL-C","title":"Author/        License"},{"location":"original/","text":"Sliced OT Color Transfer / CPU / Balanced We discuss some technical details of the Sliced OT implementation in C++. The code use classical STL containers and algorithms, stb_image.h/stb_image_writer.h for image IO and Cimg for the bilateral filter that can be used to regularize the output. Code colorTransfer.cpp Code comments First, to uniformly sample the set of directions S^3 S^3 , we first create a (seeded) random Number generator following a centered normal distribution law. //Random generator init to draw random line directions std :: mt19937 gen ; gen . seed ( 10 ); std :: normal_distribution < float > dist { 0.0 , 1.0 }; Uniform directions are then selected by normalizing the three realizations of that random number generator 1 : //Random direction float dirx = dist ( gen ); float diry = dist ( gen ); float dirz = dist ( gen ); float norm = sqrt ( dirx * dirx + diry * diry + dirz * dirz ); dirx /= norm ; diry /= norm ; dirz /= norm ; Then, the core of the method consists in computing the projections: //We project the points for ( auto i = 0 ; i < projsource . size (); ++ i ) { projsource [ i ] = dirx * source [ 3 * i ] + diry * source [ 3 * i + 1 ] + dirz * source [ 3 * i + 2 ]; projtarget [ i ] = dirx * target [ 3 * i ] + diry * target [ 3 * i + 1 ] + dirz * target [ 3 * i + 2 ]; } and sorting the id of the points according to their projection. Sorting the point sets is the bottleneck of the method. As the two sorts are independent, we can do them in parallel: std :: thread threadA ([ & ]{ std :: sort ( idSource . begin (), idSource . end (), lambdaProjSource ); }); std :: sort ( idTarget . begin (), idTarget . end (), lambdaProjTarget ); threadA . join (); with the two lambdas //Lambda expression for the comparison of points in RGB //according to their projections auto lambdaProjSource = [ & projsource ]( unsigned int a , unsigned int b ) { return projsource [ a ] < projsource [ b ]; }; auto lambdaProjTarget = [ & projtarget ]( unsigned int a , unsigned int b ) { return projtarget [ a ] < projtarget [ b ]; }; Then, advection vectors can be accumulated in a batch for ( auto i = 0 ; i < idSource . size (); ++ i ) { auto pix = idSource [ i ]; advect [ 3 * pix ] += dirx * ( projtarget [ idTarget [ i ]] - projsource [ idSource [ i ]]); advect [ 3 * pix + 1 ] += diry * ( projtarget [ idTarget [ i ]] - projsource [ idSource [ i ]]); advect [ 3 * pix + 2 ] += dirz * ( projtarget [ idTarget [ i ]] - projsource [ idSource [ i ]]); } Before being used to advect the source image points: for ( auto i = 0 ; i < 3 * N ; ++ i ) source [ i ] += advect [ i ] / ( float ) batchSize ; Usage colorTransfer Usage: ./colorTransfer [OPTIONS] Options: -h,--help Print this help message and exit -s,--source TEXT Source image -t,--target TEXT Target image -o,--output TEXT Output image -n,--nbsteps UINT Number of sliced steps (3) -b,--sizeBatch UINT Number of dirtections on a batch (1) -r,--regularization Apply a regularization step of the transport plan using bilateral filter (false). --sigmaXY FLOAT Sigma parameter in the spatial domain for the bilateral regularization (16.0) --sigmaV FLOAT Sigma parameter in the value domain for the bilateral regularization (5.0) --silent No verbose messages Timings 100 slices, default parameters, no regularization (3,5 GHz 6-Core Intel Xeon E5). ./colorTransfer -s pexelA-0.png -t pexelB-0.png -o output.png -n 100 --silent Source image: 1280x1024 (3) Target image: 1280x1024 (3) ... elapsed time: 14.5373s Muller, M. E. \u201cA Note on a Method for Generating Points Uniformly on N-Dimensional Spheres.\u201d Comm. Assoc. Comput. Mach. 2, 19-20, Apr. 1959. \u21a9","title":"Color Transfer (CPU/Balanced)"},{"location":"original/#sliced-ot-color-transfer-cpu-balanced","text":"We discuss some technical details of the Sliced OT implementation in C++. The code use classical STL containers and algorithms, stb_image.h/stb_image_writer.h for image IO and Cimg for the bilateral filter that can be used to regularize the output. Code colorTransfer.cpp","title":"Sliced OT Color Transfer / CPU / Balanced"},{"location":"original/#code-comments","text":"First, to uniformly sample the set of directions S^3 S^3 , we first create a (seeded) random Number generator following a centered normal distribution law. //Random generator init to draw random line directions std :: mt19937 gen ; gen . seed ( 10 ); std :: normal_distribution < float > dist { 0.0 , 1.0 }; Uniform directions are then selected by normalizing the three realizations of that random number generator 1 : //Random direction float dirx = dist ( gen ); float diry = dist ( gen ); float dirz = dist ( gen ); float norm = sqrt ( dirx * dirx + diry * diry + dirz * dirz ); dirx /= norm ; diry /= norm ; dirz /= norm ; Then, the core of the method consists in computing the projections: //We project the points for ( auto i = 0 ; i < projsource . size (); ++ i ) { projsource [ i ] = dirx * source [ 3 * i ] + diry * source [ 3 * i + 1 ] + dirz * source [ 3 * i + 2 ]; projtarget [ i ] = dirx * target [ 3 * i ] + diry * target [ 3 * i + 1 ] + dirz * target [ 3 * i + 2 ]; } and sorting the id of the points according to their projection. Sorting the point sets is the bottleneck of the method. As the two sorts are independent, we can do them in parallel: std :: thread threadA ([ & ]{ std :: sort ( idSource . begin (), idSource . end (), lambdaProjSource ); }); std :: sort ( idTarget . begin (), idTarget . end (), lambdaProjTarget ); threadA . join (); with the two lambdas //Lambda expression for the comparison of points in RGB //according to their projections auto lambdaProjSource = [ & projsource ]( unsigned int a , unsigned int b ) { return projsource [ a ] < projsource [ b ]; }; auto lambdaProjTarget = [ & projtarget ]( unsigned int a , unsigned int b ) { return projtarget [ a ] < projtarget [ b ]; }; Then, advection vectors can be accumulated in a batch for ( auto i = 0 ; i < idSource . size (); ++ i ) { auto pix = idSource [ i ]; advect [ 3 * pix ] += dirx * ( projtarget [ idTarget [ i ]] - projsource [ idSource [ i ]]); advect [ 3 * pix + 1 ] += diry * ( projtarget [ idTarget [ i ]] - projsource [ idSource [ i ]]); advect [ 3 * pix + 2 ] += dirz * ( projtarget [ idTarget [ i ]] - projsource [ idSource [ i ]]); } Before being used to advect the source image points: for ( auto i = 0 ; i < 3 * N ; ++ i ) source [ i ] += advect [ i ] / ( float ) batchSize ;","title":"Code comments"},{"location":"original/#usage","text":"colorTransfer Usage: ./colorTransfer [OPTIONS] Options: -h,--help Print this help message and exit -s,--source TEXT Source image -t,--target TEXT Target image -o,--output TEXT Output image -n,--nbsteps UINT Number of sliced steps (3) -b,--sizeBatch UINT Number of dirtections on a batch (1) -r,--regularization Apply a regularization step of the transport plan using bilateral filter (false). --sigmaXY FLOAT Sigma parameter in the spatial domain for the bilateral regularization (16.0) --sigmaV FLOAT Sigma parameter in the value domain for the bilateral regularization (5.0) --silent No verbose messages","title":"Usage"},{"location":"original/#timings","text":"100 slices, default parameters, no regularization (3,5 GHz 6-Core Intel Xeon E5). ./colorTransfer -s pexelA-0.png -t pexelB-0.png -o output.png -n 100 --silent Source image: 1280x1024 (3) Target image: 1280x1024 (3) ... elapsed time: 14.5373s Muller, M. E. \u201cA Note on a Method for Generating Points Uniformly on N-Dimensional Spheres.\u201d Comm. Assoc. Comput. Mach. 2, 19-20, Apr. 1959. \u21a9","title":"Timings"},{"location":"partial/","text":"Sliced OT Color Transfer / CPU / Balanced We discuss now about the Sliced Partial Optimal Transport case. For that, let us use to the optimized SPOT code ( Nicolas Bonneel , David Coeurjolly ). Code colorTransferPartial.cpp Code comments Usage colorTransferPartial Usage: ./colorTransferPartial [OPTIONS] Options: -h,--help Print this help message and exit -s,--source TEXT Source image -t,--target TEXT Target image -o,--output TEXT Output image -n,--nbsteps UINT Number of sliced steps (3) -b,--sizeBatch UINT Number of dirtections on a batch (1) -r,--regularization Apply a regularization step of the transport plan using bilateral filter (false). --sigmaXY FLOAT Sigma parameter in the spatial domain for the bilateral regularization (16.0) --sigmaV FLOAT Sigma parameter in the value domain for the bilateral regularization (5.0) --silent No verbose messages Timings 100 slices, default parameters, no regularization, same image size (3,5 GHz 6-Core Intel Xeon E5). When considering images with same size, the code has an overhead compared to the CPU/Balanced code. ./colorTransferPartial -s pexelA-0.png -t pexelB-0.png -o output.png -n 100 --silent Source image: 1280x1024 (3) Target image: 1280x1024 (3) ... elapsed time: 34.1797s When we increase the size of the target image to reproduce the results of Sliced Partial Optimal Transport : ./colorTransferPartial -s pexelA-0.png -t pexelB-0-larger.png -o output-partial.png -n 100 Source image: 1280x1024 (3) Target image: 1536x1229 (3) finished computation at Fri Aug 30 13:25:11 2019 elapsed time: 23.2826s Exporting..","title":"Color Transfer (CPU/Partial)"},{"location":"partial/#sliced-ot-color-transfer-cpu-balanced","text":"We discuss now about the Sliced Partial Optimal Transport case. For that, let us use to the optimized SPOT code ( Nicolas Bonneel , David Coeurjolly ). Code colorTransferPartial.cpp","title":"Sliced OT Color Transfer / CPU / Balanced"},{"location":"partial/#code-comments","text":"","title":"Code comments"},{"location":"partial/#usage","text":"colorTransferPartial Usage: ./colorTransferPartial [OPTIONS] Options: -h,--help Print this help message and exit -s,--source TEXT Source image -t,--target TEXT Target image -o,--output TEXT Output image -n,--nbsteps UINT Number of sliced steps (3) -b,--sizeBatch UINT Number of dirtections on a batch (1) -r,--regularization Apply a regularization step of the transport plan using bilateral filter (false). --sigmaXY FLOAT Sigma parameter in the spatial domain for the bilateral regularization (16.0) --sigmaV FLOAT Sigma parameter in the value domain for the bilateral regularization (5.0) --silent No verbose messages","title":"Usage"},{"location":"partial/#timings","text":"100 slices, default parameters, no regularization, same image size (3,5 GHz 6-Core Intel Xeon E5). When considering images with same size, the code has an overhead compared to the CPU/Balanced code. ./colorTransferPartial -s pexelA-0.png -t pexelB-0.png -o output.png -n 100 --silent Source image: 1280x1024 (3) Target image: 1280x1024 (3) ... elapsed time: 34.1797s When we increase the size of the target image to reproduce the results of Sliced Partial Optimal Transport : ./colorTransferPartial -s pexelA-0.png -t pexelB-0-larger.png -o output-partial.png -n 100 Source image: 1280x1024 (3) Target image: 1536x1229 (3) finished computation at Fri Aug 30 13:25:11 2019 elapsed time: 23.2826s Exporting..","title":"Timings"},{"location":"python/","text":"Sliced OT Color Transfer / Python exampe Here you have a python implementation by @iperov (thanks!). This code also illustrates the sliced OT color transfer in Lab color space. This code requires numpy and opencv python packages. import numpy as np from numpy import linalg as npla import cv2 def CTSOT ( src , trg , steps = 10 , batch_size = 5 , reg_sigmaXY = 16.0 , reg_sigmaV = 5.0 ): \"\"\" Color Transform via Sliced Optimal Transfer, ported by @iperov src - any float range any channel image dst - any float range any channel image, same shape as src steps - number of solver steps batch_size - solver batch size reg_sigmaXY - apply regularization and sigmaXY of filter, otherwise set to 0.0 reg_sigmaV - sigmaV of filter return value - clip it manually \"\"\" if not np . issubdtype ( src . dtype , np . floating ): raise ValueError ( \"src value must be float\" ) if not np . issubdtype ( trg . dtype , np . floating ): raise ValueError ( \"trg value must be float\" ) if len ( src . shape ) != 3 : raise ValueError ( \"src shape must have rank 3 (h,w,c)\" ) if src . shape != trg . shape : raise ValueError ( \"src and trg shapes must be equal\" ) src_dtype = src . dtype h , w , c = src . shape new_src = src . copy () for step in range ( steps ): advect = np . zeros ( ( h * w , c ), dtype = src_dtype ) for batch in range ( batch_size ): dir = np . random . normal ( size = c ) . astype ( src_dtype ) dir /= npla . norm ( dir ) projsource = np . sum ( new_src * dir , axis =- 1 ) . reshape (( h * w )) projtarget = np . sum ( trg * dir , axis =- 1 ) . reshape (( h * w )) idSource = np . argsort ( projsource ) idTarget = np . argsort ( projtarget ) a = projtarget [ idTarget ] - projsource [ idSource ] for i_c in range ( c ): advect [ idSource , i_c ] += a * dir [ i_c ] new_src += advect . reshape ( ( h , w , c ) ) / batch_size if reg_sigmaXY != 0.0 : src_diff = new_src - src new_src = src + cv2 . bilateralFilter ( src_diff , 0 , reg_sigmaV , reg_sigmaXY ) return new_src","title":"Python example code"},{"location":"python/#sliced-ot-color-transfer-python-exampe","text":"Here you have a python implementation by @iperov (thanks!). This code also illustrates the sliced OT color transfer in Lab color space. This code requires numpy and opencv python packages. import numpy as np from numpy import linalg as npla import cv2 def CTSOT ( src , trg , steps = 10 , batch_size = 5 , reg_sigmaXY = 16.0 , reg_sigmaV = 5.0 ): \"\"\" Color Transform via Sliced Optimal Transfer, ported by @iperov src - any float range any channel image dst - any float range any channel image, same shape as src steps - number of solver steps batch_size - solver batch size reg_sigmaXY - apply regularization and sigmaXY of filter, otherwise set to 0.0 reg_sigmaV - sigmaV of filter return value - clip it manually \"\"\" if not np . issubdtype ( src . dtype , np . floating ): raise ValueError ( \"src value must be float\" ) if not np . issubdtype ( trg . dtype , np . floating ): raise ValueError ( \"trg value must be float\" ) if len ( src . shape ) != 3 : raise ValueError ( \"src shape must have rank 3 (h,w,c)\" ) if src . shape != trg . shape : raise ValueError ( \"src and trg shapes must be equal\" ) src_dtype = src . dtype h , w , c = src . shape new_src = src . copy () for step in range ( steps ): advect = np . zeros ( ( h * w , c ), dtype = src_dtype ) for batch in range ( batch_size ): dir = np . random . normal ( size = c ) . astype ( src_dtype ) dir /= npla . norm ( dir ) projsource = np . sum ( new_src * dir , axis =- 1 ) . reshape (( h * w )) projtarget = np . sum ( trg * dir , axis =- 1 ) . reshape (( h * w )) idSource = np . argsort ( projsource ) idTarget = np . argsort ( projtarget ) a = projtarget [ idTarget ] - projsource [ idSource ] for i_c in range ( c ): advect [ idSource , i_c ] += a * dir [ i_c ] new_src += advect . reshape ( ( h , w , c ) ) / batch_size if reg_sigmaXY != 0.0 : src_diff = new_src - src new_src = src + cv2 . bilateralFilter ( src_diff , 0 , reg_sigmaV , reg_sigmaXY ) return new_src","title":"Sliced OT Color Transfer / Python exampe"},{"location":"todo/","text":"WIP","title":"Color Transfer (GPU/Balanced)"}]}